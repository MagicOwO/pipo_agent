import langfun as lf
import os
import pyglove as pg
from typing import TYPE_CHECKING, Any # Use TYPE_CHECKING to avoid circular import

if TYPE_CHECKING:
    from ..naive_demo import StepResult # Relative import for type hint

from .base import Action

class FinalAnswer(Action):
    # final_answer: str # Removed, will be generated by __call__
    description = "Generates and provides the final answer to the user's query based on previous steps."
    estimated_duration_seconds = 0.0 # Adjust estimate as LLM call takes time

    def __call__(self, question: str, past_steps: list['StepResult']) -> str:
        """Generates the final answer using an LLM based on the question and past steps."""
        # Use pg.typing.cast for runtime check if needed, or rely on structure
        # This assumes past_steps contains objects structurally similar to StepResult
        # If strict type checking is needed at runtime, import StepResult directly (handle potential circularity)

        result = lf.query(
            "Given the question: {{question}} and the past steps: {{past_steps}}, what is the final answer?",
            lm=lf.llms.Gpt4(api_key=os.getenv("OPENAI_API_KEY")),
            question=question,
            past_steps=past_steps,
            # Expecting the LLM to return a string directly, or structure it if needed
            # If the LLM is expected to return a FinalAnswer object, adjust the schema expectation:
            # schema=FinalAnswer # This would create recursion, likely want raw string or simple dict
            response_type=str # Expect a string answer directly
        )
        # Assuming lf.query returns the string directly when response_type=str
        # If it returns a structure, extract the answer: e.g., result['final_answer']
        final_answer_str = str(result) # Ensure it's a string
        return final_answer_str 